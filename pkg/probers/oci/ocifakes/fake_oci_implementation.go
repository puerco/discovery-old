// Code generated by counterfeiter. DO NOT EDIT.
package ocifakes

import (
	"sync"

	"github.com/google/go-containerregistry/pkg/name"
	"github.com/openvex/discovery/pkg/discovery/options"
	"github.com/openvex/go-vex/pkg/vex"
	packageurl "github.com/package-url/packageurl-go"
	ocia "github.com/sigstore/cosign/v2/pkg/oci"
)

type FakeOciImplementation struct {
	DownloadDocumentsStub        func(options.Options, ocia.SignedEntity) ([]*vex.VEX, error)
	downloadDocumentsMutex       sync.RWMutex
	downloadDocumentsArgsForCall []struct {
		arg1 options.Options
		arg2 ocia.SignedEntity
	}
	downloadDocumentsReturns struct {
		result1 []*vex.VEX
		result2 error
	}
	downloadDocumentsReturnsOnCall map[int]struct {
		result1 []*vex.VEX
		result2 error
	}
	PurlToReferenceStub        func(options.Options, packageurl.PackageURL) (name.Reference, error)
	purlToReferenceMutex       sync.RWMutex
	purlToReferenceArgsForCall []struct {
		arg1 options.Options
		arg2 packageurl.PackageURL
	}
	purlToReferenceReturns struct {
		result1 name.Reference
		result2 error
	}
	purlToReferenceReturnsOnCall map[int]struct {
		result1 name.Reference
		result2 error
	}
	ResolveImageReferenceStub        func(options.Options, name.Reference) (ocia.SignedEntity, error)
	resolveImageReferenceMutex       sync.RWMutex
	resolveImageReferenceArgsForCall []struct {
		arg1 options.Options
		arg2 name.Reference
	}
	resolveImageReferenceReturns struct {
		result1 ocia.SignedEntity
		result2 error
	}
	resolveImageReferenceReturnsOnCall map[int]struct {
		result1 ocia.SignedEntity
		result2 error
	}
	VerifyOptionsStub        func(*options.Options) error
	verifyOptionsMutex       sync.RWMutex
	verifyOptionsArgsForCall []struct {
		arg1 *options.Options
	}
	verifyOptionsReturns struct {
		result1 error
	}
	verifyOptionsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeOciImplementation) DownloadDocuments(arg1 options.Options, arg2 ocia.SignedEntity) ([]*vex.VEX, error) {
	fake.downloadDocumentsMutex.Lock()
	ret, specificReturn := fake.downloadDocumentsReturnsOnCall[len(fake.downloadDocumentsArgsForCall)]
	fake.downloadDocumentsArgsForCall = append(fake.downloadDocumentsArgsForCall, struct {
		arg1 options.Options
		arg2 ocia.SignedEntity
	}{arg1, arg2})
	stub := fake.DownloadDocumentsStub
	fakeReturns := fake.downloadDocumentsReturns
	fake.recordInvocation("DownloadDocuments", []interface{}{arg1, arg2})
	fake.downloadDocumentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOciImplementation) DownloadDocumentsCallCount() int {
	fake.downloadDocumentsMutex.RLock()
	defer fake.downloadDocumentsMutex.RUnlock()
	return len(fake.downloadDocumentsArgsForCall)
}

func (fake *FakeOciImplementation) DownloadDocumentsCalls(stub func(options.Options, ocia.SignedEntity) ([]*vex.VEX, error)) {
	fake.downloadDocumentsMutex.Lock()
	defer fake.downloadDocumentsMutex.Unlock()
	fake.DownloadDocumentsStub = stub
}

func (fake *FakeOciImplementation) DownloadDocumentsArgsForCall(i int) (options.Options, ocia.SignedEntity) {
	fake.downloadDocumentsMutex.RLock()
	defer fake.downloadDocumentsMutex.RUnlock()
	argsForCall := fake.downloadDocumentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOciImplementation) DownloadDocumentsReturns(result1 []*vex.VEX, result2 error) {
	fake.downloadDocumentsMutex.Lock()
	defer fake.downloadDocumentsMutex.Unlock()
	fake.DownloadDocumentsStub = nil
	fake.downloadDocumentsReturns = struct {
		result1 []*vex.VEX
		result2 error
	}{result1, result2}
}

func (fake *FakeOciImplementation) DownloadDocumentsReturnsOnCall(i int, result1 []*vex.VEX, result2 error) {
	fake.downloadDocumentsMutex.Lock()
	defer fake.downloadDocumentsMutex.Unlock()
	fake.DownloadDocumentsStub = nil
	if fake.downloadDocumentsReturnsOnCall == nil {
		fake.downloadDocumentsReturnsOnCall = make(map[int]struct {
			result1 []*vex.VEX
			result2 error
		})
	}
	fake.downloadDocumentsReturnsOnCall[i] = struct {
		result1 []*vex.VEX
		result2 error
	}{result1, result2}
}

func (fake *FakeOciImplementation) PurlToReference(arg1 options.Options, arg2 packageurl.PackageURL) (name.Reference, error) {
	fake.purlToReferenceMutex.Lock()
	ret, specificReturn := fake.purlToReferenceReturnsOnCall[len(fake.purlToReferenceArgsForCall)]
	fake.purlToReferenceArgsForCall = append(fake.purlToReferenceArgsForCall, struct {
		arg1 options.Options
		arg2 packageurl.PackageURL
	}{arg1, arg2})
	stub := fake.PurlToReferenceStub
	fakeReturns := fake.purlToReferenceReturns
	fake.recordInvocation("PurlToReference", []interface{}{arg1, arg2})
	fake.purlToReferenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOciImplementation) PurlToReferenceCallCount() int {
	fake.purlToReferenceMutex.RLock()
	defer fake.purlToReferenceMutex.RUnlock()
	return len(fake.purlToReferenceArgsForCall)
}

func (fake *FakeOciImplementation) PurlToReferenceCalls(stub func(options.Options, packageurl.PackageURL) (name.Reference, error)) {
	fake.purlToReferenceMutex.Lock()
	defer fake.purlToReferenceMutex.Unlock()
	fake.PurlToReferenceStub = stub
}

func (fake *FakeOciImplementation) PurlToReferenceArgsForCall(i int) (options.Options, packageurl.PackageURL) {
	fake.purlToReferenceMutex.RLock()
	defer fake.purlToReferenceMutex.RUnlock()
	argsForCall := fake.purlToReferenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOciImplementation) PurlToReferenceReturns(result1 name.Reference, result2 error) {
	fake.purlToReferenceMutex.Lock()
	defer fake.purlToReferenceMutex.Unlock()
	fake.PurlToReferenceStub = nil
	fake.purlToReferenceReturns = struct {
		result1 name.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeOciImplementation) PurlToReferenceReturnsOnCall(i int, result1 name.Reference, result2 error) {
	fake.purlToReferenceMutex.Lock()
	defer fake.purlToReferenceMutex.Unlock()
	fake.PurlToReferenceStub = nil
	if fake.purlToReferenceReturnsOnCall == nil {
		fake.purlToReferenceReturnsOnCall = make(map[int]struct {
			result1 name.Reference
			result2 error
		})
	}
	fake.purlToReferenceReturnsOnCall[i] = struct {
		result1 name.Reference
		result2 error
	}{result1, result2}
}

func (fake *FakeOciImplementation) ResolveImageReference(arg1 options.Options, arg2 name.Reference) (ocia.SignedEntity, error) {
	fake.resolveImageReferenceMutex.Lock()
	ret, specificReturn := fake.resolveImageReferenceReturnsOnCall[len(fake.resolveImageReferenceArgsForCall)]
	fake.resolveImageReferenceArgsForCall = append(fake.resolveImageReferenceArgsForCall, struct {
		arg1 options.Options
		arg2 name.Reference
	}{arg1, arg2})
	stub := fake.ResolveImageReferenceStub
	fakeReturns := fake.resolveImageReferenceReturns
	fake.recordInvocation("ResolveImageReference", []interface{}{arg1, arg2})
	fake.resolveImageReferenceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeOciImplementation) ResolveImageReferenceCallCount() int {
	fake.resolveImageReferenceMutex.RLock()
	defer fake.resolveImageReferenceMutex.RUnlock()
	return len(fake.resolveImageReferenceArgsForCall)
}

func (fake *FakeOciImplementation) ResolveImageReferenceCalls(stub func(options.Options, name.Reference) (ocia.SignedEntity, error)) {
	fake.resolveImageReferenceMutex.Lock()
	defer fake.resolveImageReferenceMutex.Unlock()
	fake.ResolveImageReferenceStub = stub
}

func (fake *FakeOciImplementation) ResolveImageReferenceArgsForCall(i int) (options.Options, name.Reference) {
	fake.resolveImageReferenceMutex.RLock()
	defer fake.resolveImageReferenceMutex.RUnlock()
	argsForCall := fake.resolveImageReferenceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeOciImplementation) ResolveImageReferenceReturns(result1 ocia.SignedEntity, result2 error) {
	fake.resolveImageReferenceMutex.Lock()
	defer fake.resolveImageReferenceMutex.Unlock()
	fake.ResolveImageReferenceStub = nil
	fake.resolveImageReferenceReturns = struct {
		result1 ocia.SignedEntity
		result2 error
	}{result1, result2}
}

func (fake *FakeOciImplementation) ResolveImageReferenceReturnsOnCall(i int, result1 ocia.SignedEntity, result2 error) {
	fake.resolveImageReferenceMutex.Lock()
	defer fake.resolveImageReferenceMutex.Unlock()
	fake.ResolveImageReferenceStub = nil
	if fake.resolveImageReferenceReturnsOnCall == nil {
		fake.resolveImageReferenceReturnsOnCall = make(map[int]struct {
			result1 ocia.SignedEntity
			result2 error
		})
	}
	fake.resolveImageReferenceReturnsOnCall[i] = struct {
		result1 ocia.SignedEntity
		result2 error
	}{result1, result2}
}

func (fake *FakeOciImplementation) VerifyOptions(arg1 *options.Options) error {
	fake.verifyOptionsMutex.Lock()
	ret, specificReturn := fake.verifyOptionsReturnsOnCall[len(fake.verifyOptionsArgsForCall)]
	fake.verifyOptionsArgsForCall = append(fake.verifyOptionsArgsForCall, struct {
		arg1 *options.Options
	}{arg1})
	stub := fake.VerifyOptionsStub
	fakeReturns := fake.verifyOptionsReturns
	fake.recordInvocation("VerifyOptions", []interface{}{arg1})
	fake.verifyOptionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeOciImplementation) VerifyOptionsCallCount() int {
	fake.verifyOptionsMutex.RLock()
	defer fake.verifyOptionsMutex.RUnlock()
	return len(fake.verifyOptionsArgsForCall)
}

func (fake *FakeOciImplementation) VerifyOptionsCalls(stub func(*options.Options) error) {
	fake.verifyOptionsMutex.Lock()
	defer fake.verifyOptionsMutex.Unlock()
	fake.VerifyOptionsStub = stub
}

func (fake *FakeOciImplementation) VerifyOptionsArgsForCall(i int) *options.Options {
	fake.verifyOptionsMutex.RLock()
	defer fake.verifyOptionsMutex.RUnlock()
	argsForCall := fake.verifyOptionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeOciImplementation) VerifyOptionsReturns(result1 error) {
	fake.verifyOptionsMutex.Lock()
	defer fake.verifyOptionsMutex.Unlock()
	fake.VerifyOptionsStub = nil
	fake.verifyOptionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeOciImplementation) VerifyOptionsReturnsOnCall(i int, result1 error) {
	fake.verifyOptionsMutex.Lock()
	defer fake.verifyOptionsMutex.Unlock()
	fake.VerifyOptionsStub = nil
	if fake.verifyOptionsReturnsOnCall == nil {
		fake.verifyOptionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.verifyOptionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeOciImplementation) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.downloadDocumentsMutex.RLock()
	defer fake.downloadDocumentsMutex.RUnlock()
	fake.purlToReferenceMutex.RLock()
	defer fake.purlToReferenceMutex.RUnlock()
	fake.resolveImageReferenceMutex.RLock()
	defer fake.resolveImageReferenceMutex.RUnlock()
	fake.verifyOptionsMutex.RLock()
	defer fake.verifyOptionsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeOciImplementation) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
